  TITLE 'str-001-clst.asm: Test CLST Instruction'
*
***********************************************************************
*
*Testcase str-001-clst
*  Test cases for variations on the CLST (Compare Logical String) instruction.
*
***********************************************************************
*
*                        str-001-clst.asm 
*
* Created and placed into the public domain 2018-12-27 by Bob Polmanter.
*
* The CLST instruction is tested against the definition in the z/Architecture
*   Principles of Operation, SA22-7832.
*
* Test data is assembled into this program, and some test data is
* generated by this program. The test script (str-001-clst.tst) that runs
* verifies the resulting status of registers and condition codes
* through Hercules R commands.
* 
*
*
* Tests performed with CLST (Compare Logical String):
*
* 1.  Ensure that a non-zero bit in R0 bits 32-55 gives PIC06
* 2.  Simple equality test; no operands cross page boundary
* 3.  Operand 1 first byte is the termination character
* 4.  Operand 2 first byte is the termination character
* 5.  Operand 1 string "less than" operand 2 string
* 6.  Operand 1 string "greater than" operand 2 string
* 7.  Operand 1 string "shorter than" operand 2 string
* 8.  Operand 1 string "longer than" operand 2 string
* 9.  Operand 1 (only) crosses a page boundary
* 10. Operand 2 (only) crosses a page boundary
* 11. Both operands cross, operand 1 closer to boundary
* 12. Both operands cross, operand 2 closer to boundary
* 13. Both operands cross, ops equidistant, large multipage compare.
*
*
* NOTE - the nature of the string instructions is such that this test
*        case will only validate properly for the string instruction
*        improvement modifications committed in December 2018.  The
*        computation of the CPU determined number of bytes is an
*        unpredictable number on real hardware (at least above the
*        minimum value) and the method used in Hercules prior to
*        instruction improvements calculated it differently than the
*        improved method.  As a result, the operand registers will
*        likely contain different values when compared by the test
*        script due to the different CPU number of bytes 
*        determined.  None of the methods are wrong, and failing
*        results in the test script are not necessarily wrong.  
*        But this program and the resulting test script comparisons
*        were written for the method used by the improved string
*        instructions (CLST, MVST, SRST).
*
*
***********************************************************************
*
*
CLST001  START 0
STRTLABL EQU   *
R0       EQU   0
R1       EQU   1
R2       EQU   2
R3       EQU   3
R4       EQU   4
R5       EQU   5
R6       EQU   6
R7       EQU   7
R8       EQU   8
R9       EQU   9
R10      EQU   10
R11      EQU   11                  
R12      EQU   12
R13      EQU   13
R14      EQU   14                  
R15      EQU   15                  
*
*
         USING *,R15
*
* Selected z/Arch low core layout
*
         ORG   STRTLABL+X'8C'      Program check interrution code
PGMINTC  DS    F
*
PGMOPSW  EQU   STRTLABL+X'150'     z/Arch Program check old PSW
*
         ORG   STRTLABL+X'1A0'     z/Arch Restart PSW
         DC    X'0000000180000000',A(0,START)
*
         ORG   STRTLABL+X'1D0'     z/Arch Program check new PSW
PGMNPSW  DC    X'0000000180000000',A(0,PROGCHK)
*
* Program check routine.  We are looking for a single specification
* exeception.  Any other program check is not expected to occur and
* results in a hard wait.
*
         ORG   STRTLABL+X'200'
PROGCHK  DS    0H             Program check occured...
         CLI   PGMINTC+3,X'06'  Specification?
         BE    CONTINUE       Yes, this is expected (once)
HALT     LPSWE HALTPSW        Unexpected PIC, disabled wait
         EJECT
***********************************************************************
*
*  Main program.
*
START    DS    0H
*
**********
* TEST 1 * Ensure any non-zero bits in R0 bits 32-55 gives PIC 06
**********
*
         LA    R0,X'400'               Set invalid termination char
         LA    R6,SHORT1               -> short string
         LA    R7,SHORT2               -> another short string
         CLST  R6,R7                   Attempt a CLST, should get PIC 6
*
CONTINUE EQU   *
         MVC   PGMNPSW,HALTPSW         Going forward, all other
*                                       program checks should halt.
*
**********
* TEST 2 * Compare short equal strings; no page boundary crossings.
**********
*
         LA    R6,SHORT1               -> string 1
         LA    R7,SHORT2               -> string 2
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT2           Save test result regs
*
**********
* TEST 3 * Compare a short string; operand 1 is the termination
********** character in the first byte.
*
         LA    R6,TERM                 -> string 1
         LA    R7,SHORT2               -> string 2
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT3           Save test result regs
*
**********
* TEST 4 * Compare a short string; operand 2 is the termination
********** character in the first byte.
*
         LA    R6,SHORT1               -> string 1
         LA    R7,TERM                 -> string 2
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT4           Save test result regs
*
**********
* TEST 5 * Compare a short string; operand 1 string is "lesser"
********** than the operand 2 string.
*
         LA    R6,LESSER               -> string 1
         LA    R7,GREATER              -> string 2
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT5           Save test result regs
*
**********
* TEST 6 * Compare a short string; operand 1 string is "greater"
********** than the operand 2 string.
*
         LA    R6,GREATER              -> string 1
         LA    R7,LESSER               -> string 2
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT6           Save test result regs
*
**********
* TEST 7 * Compare a short string; operand 1 string is "shorter"
********** than the operand 2 string.
*
         LA    R6,SHORT1               -> string 1
         LA    R7,LONGER               -> string 2
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT7           Save test result regs
*
**********
* TEST 8 * Compare a short string; operand 1 string is "longer"
********** than the operand 2 string.
*
         LA    R6,LONGER               -> string 1
         LA    R7,SHORT2               -> string 2
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT8           Save test result regs
*
**********
* PREP   * Prepare a multi-page frame area for more lengthy compares.
**********
*
         LM    R2,R5,AREA              -> large area and length
         MVCL  R2,R4                   Pad it full of X'AA'
*
**********
* TEST 9 * Compare a string; operand 1 string crosses a
********** page boundary.
*
         LM    R4,R7,TEST9             Get lengths and string ptrs
         MVI   0(R4),C'$'              Set a termination char
         MVI   0(R5),C'$'              Set a termination char
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT9           Save test result regs
         MVI   0(R4),X'AA'             Reset the termination char
         MVI   0(R5),X'AA'             Reset the termination char
*
***********
* TEST 10 * Compare a string; operand 2 string crosses a
*********** page boundary.
*
         LM    R4,R7,TEST10            Get lengths and string ptrs
         MVI   0(R4),C'$'              Set a termination char
         MVI   0(R5),C'$'              Set a termination char
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT10          Save test result regs
         MVI   0(R4),X'AA'             Reset the termination char
         MVI   0(R5),X'AA'             Reset the termination char
*
***********
* TEST 11 * Compare a string; both operands cross page boundaries;
*********** operand 1 is closer to the boundary
*
         LM    R4,R7,TEST11            Get lengths and string ptrs
         MVI   0(R4),C'$'              Set a termination char
         MVI   0(R5),C'$'              Set a termination char
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT11          Save test result regs
         MVI   0(R4),X'AA'             Reset the termination char
         MVI   0(R5),X'AA'             Reset the termination char
*
***********
* TEST 12 * Compare a string; both operands cross page boundaries;
*********** operand 2 is closer to the boundary
*
         LM    R4,R7,TEST12            Get lengths and string ptrs
         MVI   0(R4),C'$'              Set a termination char
         MVI   0(R5),C'$'              Set a termination char
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT12          Save test result regs
         MVI   0(R4),X'AA'             Reset the termination char
         MVI   0(R5),X'AA'             Reset the termination char
*
***********
* TEST 13 * Compare a string; both operands cross page boundaries;
*********** both operands equidistant from boundary; large compare.
*
         LM    R4,R7,TEST13            Get lengths and string ptrs
         MVI   0(R4),C'$'              Set a termination char
         MVI   0(R5),C'$'              Set a termination char
         BAS   R9,COMPARE              Compare the string
         STM   R6,R8,RESULT13          Save test result regs
         MVI   0(R4),X'AA'             Reset the termination char
         MVI   0(R5),X'AA'             Reset the termination char
*
*
         LPSWE WAITPSW                 EOJ, load disabled wait PSW
*
*-- CLST routine used by the tests
*
COMPARE  EQU   *
         LA    R0,C'$'                 Load termination character
         SR    R8,R8                   Init CLST counter
*
INVOKE   EQU   *
         CLST  R6,R7                   Compare the strings
         LA    R8,1(,R8)               Count executions of CLST
         BC    1,INVOKE                Restart the compare
         IPM   R8                      Put final CC in high R8
         BR    R9                      Return
*
*
         DS    0D             Ensure correct alignment for psw
WAITPSW  DC    X'0002000000000000',A(0,0) Normal end - disabled wait
HALTPSW  DC    X'0002000000000000',XL4'00',X'0000DEAD' Abnormal end
*
*
*                                      core
*                                     offset
         ORG   STRTLABL+X'700'         7xx
SHORT1   DC    CL16'SHORT STRING$   '   00
SHORT2   DC    CL16'SHORT STRING$   '   10
LESSER   DC    CL16'STRING < LOW   $'   20
GREATER  DC    CL16'STRING > HIGH  $'   30
LONGER   DC    CL16'SHORT STRING XL$'   40
TERM     DC    C'$'                     50
FFS      DC    15X'FF'                  51
*
AREA     DC    X'00002000'             -> start of multi-page area
AREALEN  DC    A(4096*16)              Size of multi=page area
ZERO     DC    A(0)
PAD      DC    X'AA000000'             MVCL pad char
*
*-- Storage addresses for Tests 9-13.  Four addresses are
*-- provided:  where to place the termination character in		
*-- strings 1 and 2, and where string 1 and 2 start.
*
*
TEST9    DS    0F                      Op 1 (only) crosses page
         DC    X'00003200'   len=x400  -> where to place term chr op 1
         DC    X'00004500'   len=x400  -> where to place term chr op 2
         DC    X'00002E00'             -> start of string (operand 1)
         DC    X'00004100'             -> start of string (operand 2)
*
TEST10   DS    0F                      Op 2 (only) crosses page
         DC    X'00002B00'   len=x800  -> where to place term chr op 1
         DC    X'00005100'   len=x800  -> where to place term chr op 2
         DC    X'00002300'             -> start of string (operand 1)
         DC    X'00004900'             -> start of string (operand 2)
*
TEST11   DS    0F                      Both cross; Op1 closer to bound
         DC    X'00003090'   len=x110  -> where to place term chr op 1
         DC    X'00005010'   len=x110  -> where to place term chr op 2
         DC    X'00002F80'             -> start of string (operand 1)
         DC    X'00004F00'             -> start of string (operand 2)
*
TEST12   DS    0F                      Both cross; Op2 closer to bound
         DC    X'00003030'   len=x0F0  -> where to place term chr op 1
         DC    X'00005070'   len=x0F0  -> where to place term chr op 2
         DC    X'00002F40'             -> start of string (operand 1)
         DC    X'00004F80'             -> start of string (operand 2)
*
TEST13   DS    0F                      Both cross; ops equidistant
         DC    X'00006080'   len=x3480 -> where to place term chr op 1
         DC    X'0000C080'   len=x3480 -> where to place term chr op 2
         DC    X'00002C00'             -> start of string (operand 1)
         DC    X'00008C00'             -> start of string (operand 2)
*
*
*  Locations for results
*
* Result fields are kept on 16-byte boundaries to more easily
* track their assembled offsets for use in the .tst script.
*
*                              offset
         ORG   STRTLABL+X'800'   8xx
RESULT2  DS    4F                 00   Register results test 2
RESULT3  DS    4F                 10   Register results test 3
RESULT4  DS    4F                 20   Register results test 4
RESULT5  DS    4F                 30   Register results test 5
RESULT6  DS    4F                 40   Register results test 6
RESULT7  DS    4F                 50   Register results test 7
RESULT8  DS    4F                 60   Register results test 8
RESULT9  DS    4F                 70   Register results test 9
RESULT10 DS    4F                 80   Register results test 10
RESULT11 DS    4F                 90   Register results test 11
RESULT12 DS    4F                 A0   Register results test 12
RESULT13 DS    4F                 B0   Register results test 13
*
*
*-- Corresponding .tst script comparisons
*
*                            0 1 2 3  4 5 6 7  8 9 A B  C D E F
*r 008E.02
*Want "PIC 06"              0006
*r 0800.0C
*Want "Test 2 R6-R8"        00000700 00000710 00000001
*r 0810.0C
*Want "Test 3 R6-R8"        00000750 00000710 10000001
*r 0820.0C
*Want "Test 4 R6-R8"        00000700 00000750 20000001
*r 0830.0C
*Want "Test 5 R6-R8"        00000727 00000737 10000001
*r 0840.0C
*Want "Test 6 R6-R8"        00000737 00000727 20000001
*r 0850.0C
*Want "Test 7 R6-R8"        0000070C 0000074C 10000001
*r 0860.0C
*Want "Test 8 R6-R8"        0000074C 0000071C 20000001
*r 0870.0C
*Want "Test 9 R6-R8"        00003000 00004300 00000002
*r 0880.0C
*Want "Test 10 R6-R8"       00002A00 00005000 00000002
*r 0890.0C
*Want "Test 11 R6-R8"       00003080 00005000 00000002
*r 08A0.0C
*Want "Test 12 R6-R8"       00002F40 00004F80 00000001
*r 08B0.0C
*Want "Test 13 R6-R8"       00006000 0000C000 00000005
*
         END
